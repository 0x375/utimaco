#!/usr/bin/python

import struct
import fcntl
import socket

class cs2:
    def __init__(self, dev):
        self.dev = dev
        if dev.startswith('PCI:'):
            self.isNet = False
        else:
            self.isNet = True

    def _connect_net(self):
        if self.isNet == False:
            raise Exception('Not a network connection')

        if self.dev.find('@') == -1:
            host = self.dev
            port = 3001
        else:
            host = self.dev.split('@')[1]
            port = int(self.dev.split('@')[0])

        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.connect((host, port))
        self._sendmsg_net('\x00\x00\x22\x00')
        self._sendmsg_net('\00\x00\x10\x00\x02')

    def _disconnect_net(self):
        if self.isNet == False:
            raise Exception('Not a network connection')

        self.s.close()

    def _sendmsg_net(self, msg):
        if self.isNet == False:
            raise Exception('Not a network connection')

        if self.s is None:
            raise Exception('Not connected')

        self.s.sendall('\x9c\x00\x00' + chr(len(msg) + 4) + msg)
        reply = self.s.recv(4)
        msglen = ord(reply[3])
        if (msglen - 4) > 0:
            reply2 = self.s.recv(msglen - 4)
            return reply + reply2
        else:
            return reply

    def _connect_local(self):
        if self.isNet == True:
            raise Exception('Not a local connection')

        if self.dev.startswith('PCI:') == False:
            raise Exception('Error in device name')

        self.fp = open(self.dev[4:], 'w+')
        fcntl.ioctl(self.fp, 0x6b08)

    def _disconnect_local(self):
        if self.isNet == True:
            raise Exception('Not a local connection')

        fcntl.ioctl(self.fp, 0x6b09)
        self.fp.close()

    def _sendmsg_local(self, msg):
        if self.isNet == True:
            raise Exception('Not a local connection')

        if self.fp is None:
            raise Exception('Not connected')

        self.fp.write('\x9c\x00\x00' + chr(len(msg) + 4) + msg)
        self.fp.flush()
        msglen = struct.unpack('iIi', fcntl.ioctl(self.fp, 0x6b02, struct.pack('iIi', 1000, 0, 0)))[1]
        return self.fp.read(msglen)

    def sendmsg(self, msg):
        if self.isNet == True:
            return self._sendmsg_net(msg)
        else:
            return self._sendmsg_local(msg)

    def connect(self):
        if self.isNet == True:
            return self._connect_net(msg)
        else:
            return self._connect_local(msg)

    def disconnect(self):
        if self.isNet == True:
            return self._disconnect_net(msg)
        else:
            return self._disconnect_local(msg)

    def dbgetentries(self, dbname):
        r = self.sendmsg('\x00\x87\x17\x00' + chr(len(dbname)) + dbname)
        if r[0] != '\x9a':
            return None
        entrylen = ord(r[7])
        entries = r[12:]
        return [entries[entrylen*i:entrylen*i+entrylen] for i in range(len(entries) / entrylen)]

    def dbreadentry(self, dbname, entry):
        r = self.sendmsg('\x00\x87\x18\x00' + chr(len(dbname)) + dbname + '\x00' + chr(len(entry)) + entry)
        return r

c = cs2('PCI:/dev/cs2')
c.connect()
print 'FLASH\\VMBK1.db entries:'
print c.dbgetentries('FLASH\\VMBK1.db')
print c.dbreadentry('FLASH\\VMBK1.db', '3')
c.disconnect()

